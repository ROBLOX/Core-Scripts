<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBX2E794D4A101246E2A297C1E0B836654A">
		<Properties>
			<string name="Name">FollowCamera</string>
			<ProtectedString name="Source">local PlayersService = game:GetService(&apos;Players&apos;)
local UserInputService = game:GetService(&apos;UserInputService&apos;)
local RootCameraCreator = require(script.Parent)

local ZERO_VECTOR = Vector3.new(0, 0, 0)
local UP_VECTOR = Vector3.new(0, 1, 0)
local XZ_VECTOR = Vector3.new(1,0,1)

local function clamp(low, high, num)
&#9;if low &lt;= high then
&#9;&#9;return math.min(high, math.max(low, num))
&#9;end
&#9;print(&quot;Trying to clamp when low:&quot;, low , &quot;is larger than high:&quot; , high , &quot;returning input value.&quot;)
&#9;return num
end

local function IsFinite(num)
&#9;return num == num and num ~= 1/0 and num ~= -1/0
end

local function IsFiniteVector3(vec3)
&#9;return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end

-- May return NaN or inf or -inf
local function findAngleBetweenXZVectors(vec2, vec1)
&#9;-- This is a way of finding the angle between the two vectors:
&#9;return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
end

-- May return NaN or inf or -inf
local function absoluteAngleBetween3dVectors(vec1, vec2)
&#9;return math.acos(vec1:Dot(vec2) / (vec1.magnitude * vec2.magnitude))
end

local humanoidCache = {}
local function findPlayerHumanoid(player)
&#9;local character = player and player.Character
&#9;if character then
&#9;&#9;local resultHumanoid = humanoidCache[player]
&#9;&#9;if resultHumanoid and resultHumanoid.Parent == character then
&#9;&#9;&#9;return resultHumanoid
&#9;&#9;else
&#9;&#9;&#9;humanoidCache[player] = nil -- Bust Old Cache
&#9;&#9;&#9;for _, child in pairs(character:GetChildren()) do
&#9;&#9;&#9;&#9;if child:IsA(&apos;Humanoid&apos;) then
&#9;&#9;&#9;&#9;&#9;humanoidCache[player] = child
&#9;&#9;&#9;&#9;&#9;return child
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function CreateFollowCamera()
&#9;local module = RootCameraCreator()
&#9;
&#9;local tweenAcceleration = math.rad(250)
&#9;local tweenSpeed = math.rad(0)
&#9;local tweenMaxSpeed = math.rad(250)
&#9;
&#9;local lastUpdate = tick()
&#9;function module:Update()
&#9;&#9;local now = tick()
&#9;&#9;local userPanningTheCamera = (self.UserPanningTheCamera == true)

&#9;&#9;if lastUpdate == nil or now - lastUpdate &gt; 1 then
&#9;&#9;&#9;module:ResetCameraLook()
&#9;&#9;&#9;self.LastCameraTransform = nil
&#9;&#9;end
&#9;&#9;
&#9;&#9;if lastUpdate then
&#9;&#9;&#9;-- Cap out the delta to 0.5 so we don&apos;t get some crazy things when we re-resume from
&#9;&#9;&#9;local delta = math.min(0.5, now - lastUpdate)
&#9;&#9;&#9;local angle = self.TurningLeft and -120 or 0
&#9;&#9;&#9;angle = angle + (self.TurningRight and 120 or 0)
&#9;&#9;&#9;if angle ~= 0 then userPanningTheCamera = true end
&#9;&#9;&#9;self:RotateCamera(self:GetCameraLook(), Vector2.new(math.rad(angle * delta), 0))
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Reset tween speed if user is panning
&#9;&#9;if userPanningTheCamera then
&#9;&#9;&#9;tweenSpeed = 0
&#9;&#9;end
&#9;&#9;

&#9;&#9;local camera = &#9;workspace.CurrentCamera
&#9;&#9;local player = PlayersService.LocalPlayer
&#9;&#9;local subjectPosition = self:GetSubjectPosition()
&#9;&#9;
&#9;&#9;if subjectPosition and player and camera then
&#9;&#9;&#9;local zoom = self:GetCameraZoom()
&#9;&#9;&#9;if zoom &lt;= 0 then
&#9;&#9;&#9;&#9;zoom = 0.1
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if self:GetShiftLock() and not self:IsInFirstPerson() then
&#9;&#9;&#9;&#9;local offset = ((self:GetCameraLook() * XZ_VECTOR):Cross(UP_VECTOR).unit * 1.75)
&#9;&#9;&#9;&#9;-- Check for NaNs
&#9;&#9;&#9;&#9;if IsFiniteVector3(offset) then
&#9;&#9;&#9;&#9;&#9;subjectPosition = subjectPosition + offset
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;zoom = math.max(zoom, 5)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if self.LastCameraTransform and not userPanningTheCamera then
&#9;&#9;&#9;&#9;&#9;local humanoid = findPlayerHumanoid(player)
&#9;&#9;&#9;&#9;&#9;local cameraSubject = camera and camera.CameraSubject
&#9;&#9;&#9;&#9;&#9;local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
&#9;&#9;&#9;&#9;&#9;local isInVehicle = cameraSubject and cameraSubject:IsA(&apos;VehicleSeat&apos;)
&#9;&#9;&#9;&#9;&#9;local isOnASkateboard = cameraSubject and cameraSubject:IsA(&apos;SkateboardPlatform&apos;)
&#9;&#9;&#9;&#9;&#9;if (isClimbing or isInVehicle or isOnASkateboard) and lastUpdate and humanoid and humanoid.Torso then
&#9;&#9;&#9;&#9;&#9;&#9;local forwardVector = humanoid.Torso.CFrame.lookVector
&#9;&#9;&#9;&#9;&#9;&#9;if isOnASkateboard then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;forwardVector = cameraSubject.CFrame.lookVector
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;local timeDelta = (now - lastUpdate)
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;tweenSpeed = clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;local percent = clamp(0, 1, tweenSpeed * timeDelta)
&#9;&#9;&#9;&#9;&#9;&#9;if not isClimbing and self:IsInFirstPerson() then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;percent = 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;local y = findAngleBetweenXZVectors(forwardVector, self:GetCameraLook())
&#9;&#9;&#9;&#9;&#9;&#9;-- Check for NaN
&#9;&#9;&#9;&#9;&#9;&#9;if IsFinite(y) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;self:RotateCamera(self:GetCameraLook(), Vector3.new(y * percent, 0, 0))
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;elseif not self:IsInFirstPerson() then
&#9;&#9;&#9;&#9;&#9;&#9;local lastVec = -(self.LastCameraTransform.p - subjectPosition)
&#9;&#9;&#9;&#9;&#9;&#9;local y = findAngleBetweenXZVectors(lastVec, self:GetCameraLook())
&#9;&#9;&#9;&#9;&#9;&#9;-- Check for NaNs
&#9;&#9;&#9;&#9;&#9;&#9;if IsFinite(y)then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;self:RotateCamera(self:GetCameraLook(), Vector3.new(y, 0, 0))
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;camera.Focus = CFrame.new(subjectPosition)
&#9;&#9;&#9;camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * self:GetCameraLook()), camera.Focus.p)
&#9;&#9;&#9;self.LastCameraTransform = camera.CoordinateFrame
&#9;&#9;end
&#9;&#9;
&#9;&#9;lastUpdate = now
&#9;end
&#9;
&#9;return module
end

return CreateFollowCamera
</ProtectedString>
		</Properties>
	</Item>
</roblox>